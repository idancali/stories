*The Carmel Way: Redefining Work In The Machine Era*

## Chapter 4: Is Software Development For Everyone?

It sure wasn't for the philosopher-artist 16 year old me. Hugo and his pet dog Uno, were two of my best friends during my teenage years. They were two cartoon characters I had dreamt up during the classes I couldn't stand, mostly English classes, in grades 10 and 11. Hugo was indifferent, always laid back and chill, and he couldn't care less about anything and anyone. Including Uno. He could never bring himself to show his poor dog any love. Well, Uno on the other hand, was this exuberant, always happy, always high energy kinda dog that just always got Hugo off his game and eventually always got him to play or do something fun.

I'm pretty sure Hugo was inspired by Meursault, the protagonist in Albert Camus' "The Stranger". A book I devoured back then and a book that I spent years trying to unpack and understand. I marvelled at Camus' ability to paint a vivid picture of apathy, a feeling well to known to teenagers since time immemorial. Especially teenagers with a tendency towards absurdism and existentialism. Looking back, I'd most likely not recommend Camus to my younger self but in the absence of a working time-machine, other than that good old memory lane, we all just have to live with how our younger self turned out in the end and make the most of it.

In between drawing, reading philosophy and writing poetry, my life was nothing short of an amalgam of poking at life and trying to express in words or pictures or rhymes, what life was whispering back to me. Needless to say, my parents and my high school guidance counsellor were equally confused about what to do with a young artist with an old soul who'd spend hours writing prose about the way a window drape moved in the wind.

"How will you feed your family with your drawings and your poetry?"

"You can't be a dreamer all your life, young man."

"How about you learn something that's useful to society? Something that makes money, you know."

I ignored it all of course, the parents, the counsellors, the well-meaning adults in my life who laughed at my jokes, cried at my poems and sighed and nodded their heads approvingly at my cartoons. Still they insisted I picked up a real career, and they rather see me hold down a good job, raise a good family and earn a good living doing something "real" with my time, not just make people laugh, cry or sigh.

I ignored them all.

### The Science-First Approach Turns Most People Away

Until my best friend, my poetry buddy and philosophy maniac who read more than I did and dreamed more than I drew, said to me one day:

"Hey, how about we enroll in that Computer Programming course next term?"

"What?", I said. "You too?"

"No man, it will be interesting. Let's see what this computer stuff is all about. Why not?"

Why not. Well, that's an intriguing way of putting it. And that's how it all began. Back in grade 10, in 1995, the year of Windows 95, floppy disks and the Pentium Pro.

How hard could computer programming be after all, right?

Well, I had no idea.

Let's just say I had never gotten a lower grade in my entire life up until that point. In fact I had pretty good grades.

That course - Grade 10 Intro to Computer Programming - well, I almost flunked it. I barely got a passing grade. That's how my lifelong lourney into Software Development actually started. By almost flunking my first programming course.

What I experienced during those few months, that seemed like never ending years to my fresh 16-year old mind, would change my life forever and it would shape my relationship with technology, and especially with how technology is taught. That's when I first realized Tech Education is horribly broken.

### Computer Science Is Not Enough Anymore 

To create great software products, you need much more than a Computer Science degree. The science of computing is absolutely necessary as it is foundational but it simply isn't enough. Anymore. To be a great Software Developer you need to be much more than a computer scientist. You need to be an artist and even more, you need to be a philosopher. That is because Software Development is part philosophy, part art and part science. This simple understanding of the nature of Software Development opens you up to a whole new level as a Software Developer.

What I experienced in that Grade 10 course, was a traditional scientific approach to software development. An approach devoid of art. And devoid of philosophy. The young 16 year old philosopher-artist me, was immediately turned off by the software-development-as-science method of teaching and my mind - and heart - completely tuned out.

"Can someone tell me how many dimensions an array can have?", the teacher asked during one of the soul-sucking, never-ending, dry lectures that drove me nuts to no end.

How many dimensions? Uhm, how many more than 3 can you have? Well, 4 if you count time and that's still a stretch. What kind of question is that, I remember thinking. Oh, and this "array" thing, what does that mean? I know she mentioned that before, right after words like "variables" and "constants" and I honestly blanked out and went straight into drawing a fresh new episode of my beloved Hugo and Uno.

"An infinite amount", replied the class genius. This was Toronto but somehow the dumbest guy in class - me - and the smartest one - the one who answered, we were both Romanians. Go figure. I guess we're everywhere, eh? That's a whole other story for another post - another time.

As soon as the teacher congratulated him - once again - for being such a smart, awesome nerd, I just literally lost it - silently of course.

My mind was racing like a hungry stallion on steroids chased by an infinite army of array-shaped monsters. Yeah - don't get me started with what my imagination can concoct when utterly confused by a concept that I fail to grasp.

"Infinite dimensions? What is he talking about now?", I whispered to my equally confused philosopher buddy who was just taking it all in with a ridiculous smirk as if he enjoyed flunking the course.

Arrays. Infinite ones too. Variables. Constants. If-statements. While loops. Coordinates. Functions. Algorithms.

Arrrgh. Stop!

I can just imagine Meursault lighting a new cigarette and blowing smoke in the teacher's face as her eyes pop out with rage, red cheeks, crisp mouth, yelling "Get out of my class!"

Alas, 16-year old me was not as assertive as Camus' apathetic hero - or actually, was he assertive, after all? Oh well. I sure wasn't. And so I strolled through that confusion as if nothing could touch me and I nonchalantly survived weeks and weeks of mental torture until that dreadful day when I got my final mark and I swore - I swore - that I'll never touch computer programming with a ten foot pole as long as I live.

## Going Beyond The Science Of Computing

That promise to myself lasted about a month.

I just couldn't figure something out.

And shortly after that course ended, during the '95 winter holidays and well into the new year, I tasked myself with getting to the bottom of it.

A crime had been committed. Not against another human being, as in a flat Sherlock Homes novel, but a graver crime, a full blown crime against humanity and against the entire noble institution we collectively call "Education". I had been through a programming course and not only could I not write a line of code but I hated it with an irrational passion. I certainly did not feel "educated". And that bugged me.

The nagging feeling wouldn't stop.

As a philosophy enthusiast, I spent a few months analyzing my utter failure in that computer programming class. I kept thinking of some of the students in the class who had so much fun programming and I couldn’t understand how someone can actually have fun with variables, arrays and even worse, n-dimensional arrays.

One particular guy in that class who was so way ahead of everyone else that he would actually code small computer games in between classes. Once in a while he would give the rest of us mere mortals a sneak preview of what he was currently working on. I once saw him demonstrating a shooting game where you had a cowboy character and you had to shoot some stuff up and you would even get points and stuff. Crazy. Awesome. That really intrigued me.

> I just couldn’t make the connection between the theory and the practice.

I couldn't figure out how you get from arrays and variables to cowboys and shooting. Right before that '95 winter holiday, I put myself out of my misery and I went and found that smart guy from my computer class. I asked him to give me a copy of the programming language we were supposed to learn in class.

That language was called Turing. I took the floppy disk home and plugged it into my very old 386 PC (those were the days) and loaded Turing up.

Wait.

Floppy disk. Programming Language on a floppy disk. Wow.

Let me say that again. This wasn't just before Facebook. Mark Zuckerberg was 11, ok. No, this was before Google. Can you imagine a world before Google?

Now, this was before Java was cool and before the Internet was widely available. Meaning, I couldn't just go online and read tutorials or anything like that. There was no "online" back then. That means, I just went and tried different things to see what would happen.

Right about that time I had a passion for Tetris so I set for myself this insane goal of writing a Tetris-like computer game and I told myself I won’t give up until I did it.

Guess what - I actually did do it.

It took me a few long weeks of trial and error but I eventually did it.

I remember it still. I ran over to my parents and told them I wrote my first computer game. Me, the heads-up-in-the-cloud-philosopher-artist teenager. I suddenly had become a programmer — and no one forced me into it. I even enjoyed it.

I was ecstatic. I felt alive. I felt on top of the world. You know that feeling when you do something insanely awesome and it's something you thought you could never - ever - ever do?

A few months before, I had almost flunked the class that was teaching us basic stuff, and now I had written an entire game, including levels and a scoring system, complete with graphics (all-be-it very primitive graphics) and all that's required to actually feel like you're playing a real game. And having fun.

> The lesson to be learned in all of this is that Software Development is more than just science.

### The Other Two Thirds Of Tech Education

But how did that happen? What did happen? How did I become a programmer all of a sudden, when just a few months before I was convinced programming was definitely not for me?

Sure, I did end up studying Computer Science and I did eventually go on to earn a Bachelor of Science but Software Development is so much more than science. The stuff that explains how computers works - the science - is crucial and fundamental. I eventually had to learn how to use variables and arrays and all that technical stuff. That was all necessary in order for me to create my first ever functional game. Absolutely necessary. But it’s not all that was required for me to create that game. Knowing the nitty gritty of programming - the science - that's not the whole story. In fact, it's not even half the story. At best, it's a third of the story.

Traditional Tech Education leaves out the other two thirds.

What they didn’t even try teaching me in that class were the other two parts — the really important ones.

They started with the "how" of Software Development. That's the go-to pedagogical approach in Tech Education, whether in worldclass Computer Science university programs, online coding courses or programming bootcamps. It's all about getting aspiring Software Developers to chew on variables and constants and arrays until they choke the life out what Software Development is really all about.

### The Philosophy of Software Development

Software Development is all about using technology to serve humanity.

Period.

It's about getting machines to do things that make our lives better. And we do that by creating useful, valuable, beautiful Software Products that human beings enjoy - and ideally even love to use.

We need to start with that when we teach technology.

We need to start with the "why" of Software Development. Effective Tech Education has to begin with The Philosophy of Software Development. With the unpacking of the reasons why anyone should even care to sit in front of a monitor and spend hours thinking and typing and fixing bugs and creating new value out of (almost) nothing. If we do that well - if we give newcomers a reason to learn to code - then they will.

Because once the philosophy of it all sinks in and you understand the immense value of possessing the ability to boss inert machines around and get them to do things that add value to the Human Experience - well that - at least to me - is mind blowing. And worth invest time and effort into.

If that teacher would've sat me down and said, "young man, let me tell you why going through this course is going to change your life and your outlook on humanity" - I would've thrown Hugo and Uno (maybe not Uno) right under the bus and I would've perked up my ears to make sure I absorb every single word that would follow.

If she would've told me that a computer is an extension of the Human Mind - I mean c'mon. Even now, 20+ years later, I still get goosebumps every time I think of a computer as an extension of the human mind. And here's the absolutely outta this world part - if the computer is an extension of the human mind - what's programming then?

It's the key to telling the computer what to do, it's a window into the computer's mind so to speak. Meaning, if one is to master computer programming - in some mysterious way - they could also - even if partially, peek into the depths of the human mind. Honestly, does anyone need more than this to at least flip the page and say ok, I'm intrigued - tell me more?

Oh, how I wish we taught young hungry minds - and maybe not so young but still hungry - that computer programming is a deeply philosophical subject matter and that it hides layers of beautiful and meaningful mysterious truths about human nature itself, if only we had the proper guidance and patience to dig deep enough.

Philosophy first. It just makes sense.

### The Art of Software Development

Next - before getting to the science - right after the philosophy and the unpacking of the "why", I would've loved to understand what it is that I'm supposed to build, before I actually get around to building it.

The creative component that makes computer programming so appealing to me and many others.

> If only they would’ve told me that Software Development is an art.

An art that would allow me to bring amazing creations to life. An art that would allow me to express my imagination. That would have been incredibly appealing to me. I would’ve learned the science behind it — gladly — in order to practice the art. In order to create.

If you give me a computer today, I see an infinite blank canvas, waiting for me to fill it with vivid expressions of my imagination.

Back then I saw nothing but a lifeless machine incapable of understanding me and unwavering in its lack of empathy at my frustration in trying to communicate with it.

What if I would've been guided, step by step, to see that machine as a beautiful instrument of immense creative potential, much like a pencil - but oh, so much more than a pencil. If someone would've opened my eyes to the simple but profound notion of using a computer as a tool for unleashing my creativity, that would've opened up an entire creative universe before my eyes. So incredibly powerful and exciting!

That's precisely what I did when I pushed myself to go home and try again, but with building a game in mind. Having that creative goal as a motivating and guiding light, fired me up and gave me a reason to go on whenever I felt like the syntax of the programming language was just ridiculous. But I put up with it because I knew it was simply a means to a higher goal.

And so looking at the Art of Software Development, understanding the "what" of the process, seeing - even if slightly - the object of your creation in the back of your mind, before starting to write a single line of code - that is powerful. It takes no technical skill whatsoever and it doesn't take a math genius to fire up the brain's imaginative power.

> Imagine it first and build it later.

If we would teach those hungry minds eager to become Software Developers, this simple lesson - imagine it first. If philosophy opens up your mind to understand, then art opens up your heart to imagine and peek into the future - at least the potential future. It gets you fired up to act in the present in such a way as to somehow make that image more and more real with every new line of code you write.

### We Need A More Comprehensive Tech Education Approach

Let's change Tech Education by teaching the Philosophy of Software Development first. Then let's take it a step further and teach the Art of Software Development. And finally, when our students understand the "why", and when they see the "what" - then, and I will add, only then - will they be ready, even more than ready - yes, willing and hungry, to learn the "how" of making it all come to life.

Philosophy. Art. And then Science.

This has worked wonders in my professional career as a Software Developer. And I'm convinced this will work in your life and in your future career as a Software Developer. We will be going through the Philosophy, the Art and also the Science of Software Development in great detail as the #CarmelStory unfolds.

Stay tuned and question everything.

As a matter of fact. Question me. Question all of this. Let me know what you think. Go for it.

Thanks for reading.